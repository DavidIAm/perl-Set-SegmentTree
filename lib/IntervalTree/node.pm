package IntervalTree::node;
# struct package auto-generated by Data::FlatTables
use strict;
use warnings;

sub new {
	my ($class, %args) = @_;
	my $self = bless {}, $class;

	$self->{min_time} = $args{min_time};
	$self->{min_node} = $args{min_node};
	$self->{max_time} = $args{max_time};
	$self->{max_node} = $args{max_node};
	$self->{key} = $args{key};

	return $self;
}

sub flatbuffers_type { 'struct' }

my %basic_types = (
	bool => { format => 'C', length => 1 },
	byte => { format => 'c', length => 1 },
	ubyte => { format => 'C', length => 1 },
	short => { format => 's<', length => 2 },
	ushort => { format => 'S<', length => 2 },
	int => { format => 'l<', length => 4 },
	uint => { format => 'L<', length => 4 },
	float => { format => 'f<', length => 4 },
	long => { format => 'q<', length => 8 },
	ulong => { format => 'Q<', length => 8 },
	double => { format => 'd<', length => 8 },
);
sub min_time { @_ > 1 ? $_[0]{min_time} = $_[1] : $_[0]{min_time} }
sub min_node { @_ > 1 ? $_[0]{min_node} = $_[1] : $_[0]{min_node} }
sub max_time { @_ > 1 ? $_[0]{max_time} = $_[1] : $_[0]{max_time} }
sub max_node { @_ > 1 ? $_[0]{max_node} = $_[1] : $_[0]{max_node} }
sub key { @_ > 1 ? $_[0]{key} = $_[1] : $_[0]{key} }

sub deserialize {
	my ($self, $data, $offset) = @_;
	$offset //= 0;
	$self = $self->new unless ref $self;

	$self->{min_time} = unpack 'l<', substr $data, $offset + 0, 4;
	$self->{min_node} = unpack 'l<', substr $data, $offset + 4, 4;
	$self->{max_time} = unpack 'l<', substr $data, $offset + 8, 4;
	$self->{max_node} = unpack 'l<', substr $data, $offset + 12, 4;
	$self->{key} = $self->deserialize_string($data, $offset + 16);

	return $self
}


sub deserialize_string {
	my ($self, $data, $offset) = @_;

	my $string_offset = $offset + unpack "L<", substr $data, $offset, 4; # dereference the string pointer
	my $string_length = unpack "L<", substr $data, $string_offset, 4; # get the length
	return substr $data, $string_offset + 4, $string_length # return a substring
}

sub deserialize_array {
	my ($self, $array_type, $data, $offset) = @_;

	$array_type = $array_type =~ s/\A\[(.*)\]\Z/$1/sr;

	$offset = $offset + unpack "L<", substr $data, $offset, 4; # dereference the array pointer
	my $array_length = unpack "L<", substr $data, $offset, 4; # get the length
	$offset += 4;

	my @array;
	if (exists $basic_types{$array_type}) { # if its an array of numerics
		@array = map { unpack $basic_types{$array_type}{format}, $_ }
			map { substr $data, $offset + $_, $basic_types{$array_type}{length} }
			map $_ * $basic_types{$array_type}{length},
			0 .. ($array_length - 1);
	
	} elsif ($array_type eq "string") { # if its an array of strings
		@array = map { $self->deserialize_string($data, $offset + $_) }
			map $_ * 4,
			0 .. ($array_length - 1);

	} elsif ($array_type =~ /\A\[/) { # if its an array of strings
		@array = map { $self->deserialize_array($array_type, $data, $offset + $_) }
			map $_ * 4,
			0 .. ($array_length - 1);
	
	} else { # if its an array of objects
		if ($array_type->flatbuffers_type eq "table") {
			@array = map { $array_type->deserialize($data, $offset + $_) }
				map $_ * 4,
				0 .. ($array_length - 1);
		} elsif ($array_type->flatbuffers_type eq "struct") {
			my $length = $array_type->flatbuffers_struct_length;
			@array = map { $array_type->deserialize($data, $offset + $_) }
				map $_ * $length,
				0 .. ($array_length - 1);
		} else {
			...
		}
	}

	return \@array
}


sub serialize {
	my ($self, $cache) = @_;

	my $data = "";
	my @reloc;

	my @objects;


	$data .= pack 'l<', $self->{min_time} // die 'struct IntervalTree::node requires field min_time';
	$data .= pack 'l<', $self->{min_node} // die 'struct IntervalTree::node requires field min_node';
	$data .= pack 'l<', $self->{max_time} // die 'struct IntervalTree::node requires field max_time';
	$data .= pack 'l<', $self->{max_node} // die 'struct IntervalTree::node requires field max_node';
	do {
		my $string_object = $self->serialize_string($self->{key});
		push @objects, $string_object;
		push @reloc, { offset => length ($data), item => $string_object, type => 'unsigned delta'};
		$data .= "\0\0\0\0";
	};


	# pad to 4 byte boundary
	$data .= pack "x" x (4 - (length ($data) % 4)) if length ($data) % 4;

	# return struct data and other objects that we've created
	return { type => "struct", data => $data, reloc => \@reloc }, @objects
}
	

sub flatbuffers_struct_length { 20 }


sub serialize_string {
	my ($self, $string) = @_;

	my $len = pack "L<", length $string;
	$string .= "\0"; # null termination byte because why the fuck not (it's part of flatbuffers)

	my $data = "$len$string";
	$data .= pack "x" x (4 - (length ($data) % 4)) if length ($data) % 4; # pad to 4 byte boundary

	return { type => "string", data => $data }
}




sub serialize_array {
	my ($self, $array_type, $array, $cache) = @_;

	$array_type = $array_type =~ s/\A\[(.*)\]\Z/$1/sr;

	my $data = pack "L<", scalar @$array;
	my @array_objects;
	my @reloc;

	if (exists $basic_types{$array_type}) { # array of scalar values
		$data .= join "", map { pack $basic_types{$array_type}{format}, $_ } @$array;

	} elsif ($array_type eq "string") { # array of strings
		$data .= "\0\0\0\0" x @$array;
		for my $i (0 .. $#$array) {
			my $string_object = $self->serialize_string($array->[$i]);
			push @array_objects, $string_object;
			push @reloc, { offset => 4 + $i * 4, item => $string_object, type => "unsigned delta" };
		}
	} elsif ($array_type =~ /\A\[/) { # array of arrays
		$data .= "\0\0\0\0" x @$array;
		for my $i (0 .. $#$array) {
			my ($array_object, @child_array_objects) = $self->serialize_array($array_type, $array->[$i], $cache);
			push @array_objects, $array_object, @child_array_objects;
			push @reloc, { offset => 4 + $i * 4, item => $array_object, type => "unsigned delta" };
		}

	} else { # else an array of objects
		if ($array_type->flatbuffers_type eq "table") {
			$data .= "\0\0\0\0" x @$array;
			for my $i (0 .. $#$array) {
				my ($root_object, @table_objects) = $array->[$i]->serialize($cache);
				push @array_objects, $root_object, @table_objects;
				push @reloc, { offset => 4 + $i * 4, item => $root_object, type => "unsigned delta" };
			}
		} elsif ($array_type->flatbuffers_type eq "struct") {
			for my $i (0 .. $#$array) {
				my ($root_object, @struct_objects) = $array->[$i]->serialize($cache);
				push @array_objects, @struct_objects;
				push @reloc, map { $_->{offset} += length ($data); $_ } @{$root_object->{reloc}};
				$data .= $root_object->{data};

			}
		} else {
			...
		}
	}

	return { type => "array", data => $data, reloc => \@reloc }, @array_objects
}


1 # true return from package

